
class Calculator {
  int num1;
  int num2;
  
   void setData(int n1,int n2){
    num1=n1;
    num2=n2;
   }

   void display(){
   System.out.println(num1);
   System.out.println(num2);
   }

   int add(){
     int result=num1+num2;
     return result
    }

    public static void main(String args[]){
     int ch=0;
     int num1;
     int num2;
     Calculator calc=new Calculator();
     Scanner scan=new Scanner(System.in);
     start of the loop {    
      System.out.println("STORE THE VALUE OF NUM1 and NUM2");
     
      ch=scan.nextInt();
      switch(ch) : 
                    
       case 1 :  num1=scan.nextInt();

   }
  }     
---------------------------------------------------------------------------------------
class Customer {
	public String customerId;
	public String customerName;
	public long contactNumber;
	public String address;
}
public class Tester {
	public static void main(String args[]) {
		Customer customer1 = new Customer();
		System.out.println(customer1.customerId);
		System.out.println(customer1.customerName);
		System.out.println(customer1.contactNumber);
                System.out.println(customer1.address);
	}
}
      
Observation:-
1) We are writing two separate classes.
2) main method is kept in a separate class called Tester( we can have any class).
3) We have not initialised the instance variable of Customer class.
4) While displaying the customerId, customerName, address we are able to see null and for contactNumber we see a value of 0.
   These are the default value. For any reference type the default value is null.
5) Here we have not provided any constructor so during the compilation default constructor is provided to the Customer class
   because of that during the execution of the above code we are able to see the default values as null and 0.



------------------------------------------------------------------------------------------------------------

Constructors
* Constructors are used to initialise member variables and so ultimately initialising objects.
* Constructors are having the same name as that of the class name.
* Constructors are methods.
* With constructor we dont write any return type.
* We can have two types of cosntructors - 1)default/parameterless 2) parameterized constructor

public class Numbers1{
   private int num1;
   private int num2;
  
   void setData(int n1, int n2){
    num1=n1;
    num2=n2;
   }

   void dispData(){
   System.out.println(num1);
   System.out.println(num2);
   }
 }

public class NumbersMain1 {
   public static void main(String args[]){
      Numbers1 number=new Numbers1();  // Number1() is a parmeterless/default constructor
      number.dispData();  // 0 0
      number.setData(3,4);
      number.dispData();  // 3 4
    }
 } 
  
 1 Numbers1 number1=new Numbers1();
 2 Numbers1 number2=new Numbers1();

 The above two lines can be explained as we created two reference variables number1 and number2
 of Numbers1 type ( non primitive/reference type). Here two objects are created and their respective
 address are stored in numbers1 and numbers.  

3 Numbers1 number1=new Numbers1();
4 Numbers1 number2=number1;

So we have two reference variables but one object. The object is created in line 3 and address of that
object is stored in number1 after that in line4 , we are copying that address in number2. 



  
Q How the member variables are getting the default value as 0?
A because of the constructor. Though currently in our code , we have not defined any constructor but
  during the compilation time , the code is provided with the default constructor.

--------------------------------------------------------------------------------------------------------------------------------------
Q Can we define our own default or parameterless constructor?
A Yes

public class Numbers2{
   private int num1;
   private int num2;
  // The below is the parameterless constructor
   Numbers2(){
    num1=1;
    num2=2;
   }

  /*  Numbers2(){
    num1=3;
    num2=4;
   }
Duplicate method Numbers2() in type Numbers2 */

   void setData(int n1, int n2){
    num1=n1;
    num2=n2;
   }

   void dispData(){
   System.out.println(num1);
   System.out.println(num2);
   }
 }

public class NumbersMain2 {
   public static void main(String args[]){
      Numbers2 number=new Numbers2();  // Number2() is a parmeterless/default constructor
      Numbers2 number2=new Numbers2(); 
      number.dispData();  // 1 2
      number.setData(3,4);
      number.dispData();  // 3 4
    }
 } 
  
------------------------------------------------------------------------------------------------
Q Can we set the value with the constructors only and not writing setData kind of function?
A yes we can do but that wont be the correct approach of writing the code. The reason
is constructor is invoked once only during the object creation. We cannot call the
constructor repeatedly. If we are doing so every time we are creating a new object.
But during the usage of the object we may change the data of an object and
the only solution left is setData kind of methods.

1  Customer c=new Customer(1,"Tom");
2  c=new Customer(1,"Tommy");
/* In the above lines one object is created in line1 and reference is stored
in c. In line 2 in the reference c we are overwriting the address of the
object created in line1 with the object created in line2 */



 Q What about parameterized constructor?
 A 

public class Numbers3{
   private int num1;
   private int num2;
  // The below is the parameter constructor
   Numbers3(int n1,int n2){
    num1=n1;
    num2=n2;
   }

   void setData(int n1, int n2){
    num1=n1;
    num2=n2;
   }

   void dispData(){
   System.out.println(num1);
   System.out.println(num2);
   }
 }

public class NumbersMain3 {
   public static void main(String args[]){
      Numbers3 number=new Numbers3(1,2);  // Number2(1,2) is a parmeterized constructor
      number.dispData();  // 1 2
      number.setData(3,4);
      number.dispData();  // 3 4
    }
 } 
 
-------------------------------------------------------------------------------------------------------
Q Can we have both parameterless and parameterized constructor in the same class.
A Yes we can have. In the below example while creation of number1 , parameterless constructor is invoked
and while creation of number2 parameterized constructor is invoked.


public class Numbers4{
   private int num1;
   private int num2;
  // The below is the parameterless constructor
  Numbers4(){
   num1=1;
   num2=2;
  }
  // The below is the parameterized constructor
   Numbers4(int n1,int n2){
    num1=n1;
    num2=n2;
   }

   void setData(int n1, int n2){
    num1=n1;
    num2=n2;
   }

   void dispData(){
   System.out.println(num1);
   System.out.println(num2);
   }
 }

public class NumbersMain4 {
   public static void main(String args[]){
      Numbers4 number1=new Numbers4();  // Number4() is a parmeterless constructor
      Numbers4 number2=new Numbers4(3,4); // Number4(int,int) is a parameterized constructor
      number1.dispData();  // 1 2 
      number1.setData(100,200);
      number1.dispData();  //100 200
      number2.dispData();  // 3 4 
      number2.setData(300,400);
      number2.dispData();  //300 400
   
    }
 } 
--------------------------------------------------------------------------------------------------------
We can have one parameterless constructor and we can have multiple parameterized constructors. But those
multiple parameterized constructor should have different numbers of parameter or different datatypes.

public class Numbers5 {
   private int num1;
   private int num2;
   private float f1;
   private float f2;

  Numbers5(){
    num1=1;
    num2=2;
    f1=12.34f;
    f2=12.345f;
  }

 Numbers5(int n1,int n2, float ff1, float ff2){
    num1=n1;
    num2=n2;
    f1=ff1;
    f2=ff2;
   }

  Numbers5(int n1,int n2){
   num1=n1;
   num2=n2;
  }

  Numbers5(float ff1, float ff2){
   f1=ff1;
   f2=ff2;
  }

  Numbers5(int n1, float ff1){
   num1=n1;
   f2=ff1;
  }

/* Numbers5(int nn1,int nn2){
  num1=nn1;
  num2=nn2; 
} */
}

public class NumbersMain5{
  public static void main(String args[]) {
     Numbers5 number1=new Numbers5();
     Numbers5 number2=new Numbers5(1,2);
     Numbers5 number3=new Numbers5(1.2f,3.4f);
     Numbers5 number4=new Numbers(1,3,2.35f,4.5f);
   }
}


We have to create a class called Student. Student will have roll,name and 3 subjects . The names of the subjects
are English,Maths,Sc and the subject name is same for all the student.
Create two student objects with the data.

1
Ram
English
Maths
Sc

2
Ashok
English
Maths
Sc

[Hint:

public class Student1 {
 int roll;
 String name;
 String subject1;
 String subject2;
 String subject3;
 
 Student1(){
	 subject1="Maths";
	 subject2="English";
	 subject3="Science";
	 name="No name";
	 
 }
 
 Student1(int r,String n)
 {
	 roll=r;
	 name=n;
	 subject1="Maths";
	 subject2="English";
	 subject3="Science"; 
 }
 void setData(int r,String n)
 {
	roll=r;
	name=n;
 }
 void displayData()
 {
	System.out.println(roll);
	System.out.println(name);
	System.out.println(subject1);
	System.out.println(subject2);
	System.out.println(subject3);
 }
}


public class StudentMain1 {

	public static void main(String[] args) {
	Student1 student1=new Student1();
	student1.displayData();
        student1.setData(1, "Anil");
        student1.displayData();
        Student1 student2=new Student1(2,"Suresh");
        student2.displayData();
        student2.setData(2, "Nitin");
        student2.displayData();
        		
	}

}


 
--------------------------------------------------------------------------------------------------------------------
public class Employee {
private int id;
private String name;
private String desig;
private String dept;
private long basic;

Employee(int i,String nm, String dsg, String dpt, long bs)
{
	id=i;
	name=nm;
	desig=dsg;
	dept=dpt;
	basic=bs;
}

void setData(int i,String nm, String dsg, String dpt, long bs) {
	id=i;
	name=nm;
	desig=dsg;
	dept=dpt;
	basic=bs;
	
}

void display() {
	System.out.println(id);
	System.out.println(name);
	System.out.println(desig);
	System.out.println(dept);
	System.out.println(basic);
	
}

}



public class EmployeeMain {

	public static void main(String[] args) {
		Employee employee=new Employee(1,"Rohan","Mgr","HR",34000);
		employee.display();
		employee.setData(1,"Rohit","Mgr","HR",44000);
		employee.display();

	}

}
-------------------------------------------------------------------------------------------------
Q If we keep the parameter names and the instance variable names same , in that case what will happen?
A In that case the parameters which are local variables shadows the instance variables.


public class Employee2 {
private int id;
private String name;
private String desig;
private String dept;
private long basic;

Employee2(int id,String name, String desig, String dept, long basic)
{
	id=id;  // The local variable id is being assigned  to local variable id
	name=name;
	desig=desig;
	dept=dept;
	basic=basic;
}

void setData(int id,String name, String desig, String dept, long basic) {
	// To the local id we are assigning the value of local id
	id=id;
	name=name;
	desig=desig;
	dept=dept;
	basic=basic;
}
	


void display() {
	System.out.println(id);
	System.out.println(name);
	System.out.println(desig);
	System.out.println(dept);
	System.out.println(basic);
	
}

}


public class EmployeeMain2 {

	public static void main(String[] args) {
		Employee2 employee=new Employee2(1,"Rohan","Mgr","HR",34000); // 0 null null null 0
		employee.display();
		employee.setData(1,"Rohit","Mgr","HR",44000);
		employee.display();   //0 null null null 0

	}

}
---------------------------------------------------------------------------------------------------------------------------------------
Q What is the solution if we want to keep the instance variable and the parameter name same?
A make use of this keyword alongwith with the instance variable. this represents the current object. 


public class Employee3 {
private int id;
private String name;
private String desig;
private String dept;
private long basic;

Employee3(int id,String name, String desig, String dept, long basic)
{
	this.id=id;  // this.id means this is representing the current object and id is the instance variable of the current object
	this.name=name;  //id is the parameter/local variable
	this.desig=desig;
	this.dept=dept;
	this.basic=basic;
}

void setData(int id,String name, String desig, String dept, long basic) {
	// To the local id we are assigning the value of local id
	this.id=id;
	this.name=name;
	this.desig=desig;
	this.dept=dept;
	this.basic=basic;
}
	


void display() {
	System.out.println(id);
	System.out.println(name);
	System.out.println(desig);
	System.out.println(dept);
	System.out.println(basic);
	
}

}

public class EmployeeMain3 {

	public static void main(String[] args) {
		Employee3 employee=new Employee3(1,"Rohan","Mgr","HR",34000);
		employee.display();
		employee.setData(1,"Rohit","Mgr","HR",44000);
		employee.display();

	}

}
-------------------------------------------------------------------------------------------------------------------------------------
Do we have any other usage of this apart from the usage which we have seen just now?
Yes, it is used for constructor chaining.

What is constructor chaining?
When we invoke one of the constructor from another constructor, it is called constructor chaining.


Without constructor chaining

public class Item1 {
   private int id;
   private String desc;
   private float price;

   Item1(){
     id=1;
     desc="Coffee";
     price=100;
    }

   Item1(int id, String desc, float price){
    this.id=id;
    this.desc=desc;
    this.price=price;
   }

   void display(){
    System.out.println("The id :"+id);
    System.out.println("The desc :"+desc);
    System.out.println("The price :"+price);
   }
}

public class ItemMain1 {
   public static void main(String args[]) {
    Item1 item1=new Item1();
    item1.display();
    Item1 item2=new Item1(2,"Tea",50);
    item2.display();
  }
}
--------------------------------------------------------------------------------------------------------------------------------------------------
 
  With constructor chaining

public class Item2 {
   private int id;
   private String desc;
   private float price;

   Item2(){
    this(1,"Coffee",100);
    }

   Item2(int id, String desc, float price){
    this.id=id;
    this.desc=desc;
    this.price=price;
   }

   void display(){
    System.out.println("The id :"+id);
    System.out.println("The desc :"+desc);
    System.out.println("The price :"+price);
   }
}

public class ItemMain2 {
   public static void main(String args[]) {
    Item2 item1=new Item2();
    item1.display();
    Item2 item2=new Item2(2,"Tea",50);
    item2.display();
  }
}
----------------------------------------------------------------
In constructor chaining , calling the other constructor with this should be the first line otherwise it is a compilation error
The below constructor writing is incorrect.  

Item2(){
    System.out.println("Constructor");
    this(1,"Coffee",100);
    }
[ In the above code we get compilation error as Constructor call must be the first statement in a constructor]
The below constructor writing is fine as the constructor call with this is the first line.
Item2(){
    
    this(1,"Coffee",100);
    System.out.println("Constructor");
    }
-----------------------------------------------------------------------------------------------------------------------------------------------------------
this() cannot be used inside a method. 

  example you cannot write

   void display(){
     this();
   }